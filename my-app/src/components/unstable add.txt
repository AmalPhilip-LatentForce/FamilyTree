// import React, { useState, useEffect, useRef } from 'react';
// import * as d3 from 'd3';

// const parseGEDCOM = (content) => {
//   const lines = content.split('\n');
//   const individuals = {};
//   const families = {};
//   let currentEntity = null;
//   let currentType = null;
//   let currentSubTag = null;

//   lines.forEach(line => {
//     if (!line.trim()) return;
    
//     const [level, ...rest] = line.trim().split(' ');
//     const levelNum = parseInt(level);
    
//     if (levelNum === 0) {
//       const id = rest[0];
//       const type = rest[1];
      
//       if (type === 'INDI') {
//         currentType = 'INDI';
//         currentEntity = id.replace(/@/g, '');
//         individuals[currentEntity] = { 
//           id: currentEntity,
//           name: 'Unknown',
//           gender: 'U',
//           birth: {}
//         };
//       } else if (type === 'FAM') {
//         currentType = 'FAM';
//         currentEntity = id.replace(/@/g, '');
//         families[currentEntity] = { 
//           id: currentEntity,
//           husband: null,
//           wife: null,
//           children: []
//         };
//       } else {
//         currentType = null;
//         currentEntity = null;
//       }
//     } else if (currentEntity) {
//       const tag = rest[0];
//       const value = rest.slice(1).join(' ');

//       if (currentType === 'INDI') {
//         switch(tag) {
//           case 'NAME':
//             individuals[currentEntity].name = value.replace(/\//g, '').trim() || 'Unknown';
//             break;
//           case 'SEX':
//             individuals[currentEntity].gender = value || 'U';
//             break;
//           case 'BIRT':
//             currentSubTag = 'BIRT';
//             break;
//           case 'DATE':
//             if (currentSubTag === 'BIRT') {
//               individuals[currentEntity].birth.date = value;
//             }
//             break;
//           default:
//             break;
//         }
//       } else if (currentType === 'FAM') {
//         switch(tag) {
//           case 'HUSB':
//             families[currentEntity].husband = value.replace(/@/g, '');
//             break;
//           case 'WIFE':
//             families[currentEntity].wife = value.replace(/@/g, '');
//             break;
//           case 'CHIL':
//             const childId = value.replace(/@/g, '');
//             if (!families[currentEntity].children.includes(childId)) {
//               families[currentEntity].children.push(childId);
//             }
//             break;
//           default:
//             break;
//         }
//       }
//     }
//   });

//   return { individuals, families };
// };

// const PersonDetailsPanel = ({ person, onClose, onSave, individuals, families }) => {
//   const [isEditing, setIsEditing] = useState(false);
//   const [editedPerson, setEditedPerson] = useState(person);
//   const [selectedRelativePerson, setSelectedRelativePerson] = useState(null);
//   const [relationship, setRelationship] = useState(null);
//   const [addingRelativeType, setAddingRelativeType] = useState(null);
//   const [showAddRelative, setShowAddRelative] = useState(false);
//   const [childPartnerType, setChildPartnerType] = useState(null);

// const handleAddRelative = (type) => {
//   setAddingRelativeType(type);
//   setShowAddRelative(true);
// };

// const handleSaveNewRelative = (type, newPerson, otherParent = null) => {
//   // Generate a new unique ID for the person
//   const newId = `I${Date.now()}`;
//   const newPersonWithId = {
//     ...newPerson,
//     id: newId
//   };

//   // Create new family connections based on the relationship type
//   const newFamily = {
//     id: `F${Date.now()}`,
//     husband: null,
//     wife: null,
//     children: []
//   };

//   const updatedIndividuals = {
//     ...individuals,
//     [newId]: newPersonWithId
//   };

//   const updatedFamilies = {
//     ...families
//   };
  

//   // Update the parents case in handleSaveNewRelative:
// if (type === 'parents') {
//   // Create both parents at once
//   const fatherId = person.gender === 'M' ? newId : `I${Date.now() + 1}`;
//   const motherId = person.gender === 'F' ? newId : `I${Date.now() + 1}`;
  
//   const father = {
//     id: fatherId,
//     name: person.gender === 'M' ? newPerson.name : otherParent.name,
//     gender: 'M',
//     birth: { date: person.gender === 'M' ? newPerson.birth.date : otherParent.birth.date }
//   };
  
//   const mother = {
//     id: motherId,
//     name: person.gender === 'F' ? newPerson.name : otherParent.name,
//     gender: 'F',
//     birth: { date: person.gender === 'F' ? newPerson.birth.date : otherParent.birth.date }
//   };

//   updatedIndividuals[fatherId] = father;
//   updatedIndividuals[motherId] = mother;

//   // Create family connecting both parents to the person
//   newFamily.husband = fatherId;
//   newFamily.wife = motherId;
//   newFamily.children = [person.id];
//   updatedFamilies[newFamily.id] = newFamily;
//   } else if (type === 'child') {
//     // Handle child with specified parents
//     const parentFamily = {
//       id: `F${Date.now() + 2}`,
//       husband: newPerson.parentIds.father || null,
//       wife: newPerson.parentIds.mother || null,
//       children: [newId]
//     };
//     updatedFamilies[parentFamily.id] = parentFamily;
//   } else if (type === 'sibling') {
//     // Find the person's parent family and add the new person as a child
//     Object.values(updatedFamilies).forEach(family => {
//       if (family.children.includes(person.id)) {
//         family.children.push(newId);
//       }
//     });
//   }
//   else if (type === 'partner') {
//     if (newPerson.existingPartnerId) {
//       // Link with existing partner
//       newFamily.children = [];
//       if (person.gender === 'M') {
//         newFamily.husband = person.id;
//         newFamily.wife = newPerson.existingPartnerId;
//       } else {
//         newFamily.husband = newPerson.existingPartnerId;
//         newFamily.wife = person.id;
//       }
//     } else if (type === 'newPrimaryPartner') {
//       if (person.gender === 'M') {
//         newFamily.husband = person.id;
//         newFamily.wife = newId;
//       } else {
//         newFamily.husband = newId;
//         newFamily.wife = person.id;
//       }
//     } else if (type === 'newExPartner') {
//       // Handle ex-partner case
//       if (person.gender === 'M') {
//         newFamily.husband = person.id;
//         newFamily.wife = newId;
//         newFamily.status = 'divorced';
//       } else {
//         newFamily.husband = newId;
//         newFamily.wife = person.id;
//         newFamily.status = 'divorced';
//       }
//     }
//     updatedFamilies[newFamily.id] = newFamily;
//   }

//   // Create updated GEDCOM content
//   const updatedGedcom = generateUpdatedGEDCOM(updatedIndividuals, updatedFamilies);

//   // Call the parent component's save handler with all updated data
//   onSave({
//     ...person,
//     __updates: {
//       individuals: updatedIndividuals,
//       families: updatedFamilies,
//       gedcom: updatedGedcom
//     }
//   });

//   setShowAddRelative(false);
//   setAddingRelativeType(null);
// };

// const findRelationship = (relativeId) => {
//     if (!relativeId || !person) {
//       setRelationship(null);
//       return;
//     }

//     const relativePerson = individuals[relativeId];
    
//     // Helper function to find all ancestors up to N generations
//     const findAncestors = (personId, generations = 4) => {
//       const ancestors = new Set();
//       const queue = [{id: personId, generation: 0}];
      
//       while (queue.length > 0) {
//         const current = queue.shift();
//         if (current.generation >= generations) continue;
        
//         // Find parents through families
//         Object.values(families).forEach(family => {
//           if (family.children.includes(current.id)) {
//             if (family.husband) {
//               ancestors.add(family.husband);
//               queue.push({id: family.husband, generation: current.generation + 1});
//             }
//             if (family.wife) {
//               ancestors.add(family.wife);
//               queue.push({id: family.wife, generation: current.generation + 1});
//             }
//           }
//         });
//       }
//       return ancestors;
//     };

//     // Find all descendants up to N generations
//     const findDescendants = (personId, generations = 4) => {
//       const descendants = new Set();
//       const queue = [{id: personId, generation: 0}];
      
//       while (queue.length > 0) {
//         const current = queue.shift();
//         if (current.generation >= generations) continue;
        
//         Object.values(families).forEach(family => {
//           if (family.husband === current.id || family.wife === current.id) {
//             family.children.forEach(childId => {
//               descendants.add(childId);
//               queue.push({id: childId, generation: current.generation + 1});
//             });
//           }
//         });
//       }
//       return descendants;
//     };

//     // Check for direct relationships first
//     // Spouse
//     const isSpouse = Object.values(families).some(family => 
//       (family.husband === person.id && family.wife === relativeId) ||
//       (family.wife === person.id && family.husband === relativeId)
//     );
    
//     if (isSpouse) {
//       setRelationship(relativePerson.gender === 'M' ? 'Husband' : 'Wife');
//       return;
//     }

//     // Parent-Child
//     const parentChildFamily = Object.values(families).find(family => {
//       const isParent = (family.husband === person.id || family.wife === person.id) && 
//                       family.children.includes(relativeId);
//       const isChild = (family.husband === relativeId || family.wife === relativeId) && 
//                      family.children.includes(person.id);
//       return isParent || isChild;
//     });

//     if (parentChildFamily) {
//       if (parentChildFamily.children.includes(relativeId)) {
//         setRelationship(relativePerson.gender === 'M' ? 'Son' : 'Daughter');
//         return;
//       } else if (parentChildFamily.children.includes(person.id)) {
//         setRelationship(relativePerson.gender === 'M' ? 'Father' : 'Mother');
//         return;
//       }
//     }

//     // Sibling
//     const areSiblings = Object.values(families).some(family => 
//       family.children.includes(person.id) && family.children.includes(relativeId)
//     );

//     if (areSiblings) {
//       setRelationship(relativePerson.gender === 'M' ? 'Brother' : 'Sister');
//       return;
//     }

//     // Check for more distant relationships
//     const personAncestors = findAncestors(person.id);
//     const personDescendants = findDescendants(person.id);
//     const relativeAncestors = findAncestors(relativeId);
//     const relativeDescendants = findDescendants(relativeId);

//     // Check for uncle/aunt or nephew/niece relationships
//     const personParents = new Set();
//     const relativeParents = new Set();
    
//     Object.values(families).forEach(family => {
//       if (family.children.includes(person.id)) {
//         if (family.husband) personParents.add(family.husband);
//         if (family.wife) personParents.add(family.wife);
//       }
//       if (family.children.includes(relativeId)) {
//         if (family.husband) relativeParents.add(family.husband);
//         if (family.wife) relativeParents.add(family.wife);
//       }
//     });

//     const isUncleAunt = Array.from(personParents).some(parentId => 
//       Object.values(families).some(family => 
//         family.children.includes(parentId) && 
//         (family.children.includes(relativeId) || family.husband === relativeId || family.wife === relativeId)
//       )
//     );

//     const isNephewNiece = Array.from(relativeParents).some(parentId => 
//       Object.values(families).some(family => 
//         family.children.includes(parentId) && 
//         (family.children.includes(person.id) || family.husband === person.id || family.wife === person.id)
//       )
//     );

//     if (isUncleAunt) {
//       setRelationship(relativePerson.gender === 'M' ? 'Uncle' : 'Aunt');
//       return;
//     }

//     if (isNephewNiece) {
//       setRelationship(relativePerson.gender === 'M' ? 'Nephew' : 'Niece');
//       return;
//     }

//     // Cousin check
//     const hasCommonAncestor = Array.from(personAncestors).some(ancestor => 
//       relativeAncestors.has(ancestor)
//     );

//     if (hasCommonAncestor) {
//       setRelationship('Cousin');
//       return;
//     }

//     // Grandparent/Grandchild
//     if (personDescendants.has(relativeId)) {
//       setRelationship(relativePerson.gender === 'M' ? 'Grandson' : 'Granddaughter');
//       return;
//     }

//     if (relativeDescendants.has(person.id)) {
//       setRelationship(relativePerson.gender === 'M' ? 'Grandfather' : 'Grandmother');
//       return;
//     }

//     setRelationship('Relative');
//   };

//   useEffect(() => {
//     setEditedPerson(person);
//     setIsEditing(false);
//   }, [person]);

//   const handleChange = (field, value) => {
//     setEditedPerson(prev => {
//       if (field === 'birth') {
//         return {
//           ...prev,
//           birth: { ...prev.birth, date: value }
//         };
//       }
//       return {
//         ...prev,
//         [field]: value
//       };
//     });
//   };

//   const handleSave = () => {
//     onSave(editedPerson);
//     setIsEditing(false);
//   };
//   // Add these new components inside PersonDetailsPanel, before the return statement
//   // Update AddRelativeButtons component
// const AddRelativeButtons = ({ person, onAddRelative }) => {
//   return (
//     <div className="mt-4 space-y-2">
//       <h4 className="font-medium text-sm mb-2">Add relatives:</h4>
//       <button
//         onClick={() => onAddRelative('parents')}
//         className="w-full px-3 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50"
//       >
//         Add parents
//       </button>
//       <button
//         onClick={() => onAddRelative('partner')}
//         className="w-full px-3 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50"
//       >
//         Add partner
//       </button>
//       <button
//         onClick={() => onAddRelative('childWithPartner')}  // Updated
//         className="w-full px-3 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50"
//       >
//         Add child with existing partner
//       </button>
//       <button
//         onClick={() => onAddRelative('childWithNewPartner')}  // Updated
//         className="w-full px-3 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50"
//       >
//         Add child with new partner
//       </button>
//       <button
//         onClick={() => onAddRelative('child')}
//         className="w-full px-3 py-2 text-sm text-gray-700 border border-gray-300 rounded-md hover:bg-gray-50"
//       >
//         Add child without partner
//       </button>
//     </div>
//   );
// };

// const AddRelativeForm = ({ type, person, onSave, onCancel, individuals = {}, families = {} }) => {  const [relativeName, setRelativeName] = useState('');
//   const [surname, setSurname] = useState('');
//   const [gender, setGender] = useState('F');
//   const [birthDate, setBirthDate] = useState('');
//   const [isLiving, setIsLiving] = useState(true);
//   const [fatherId, setFatherId] = useState('');
//   const [motherId, setMotherId] = useState('');
//   const [partnerId, setPartnerId] = useState('');
//   const [otherParentName, setOtherParentName] = useState('');
//   const [otherParentGender, setOtherParentGender] = useState('');
//   const [otherParentBirthDate, setOtherParentBirthDate] = useState('');
//   const [selectedPartnerType, setSelectedPartnerType] = useState('new'); // 'new' or 'existing'

//   const getRelativeLabel = () => {
//     switch (type) {
//       case 'parents':
//         return gender === 'M' ? `${person.name}'s father` : `${person.name}'s mother`;
//       case 'partner':
//         return `${person.name}'s partner`;
//       case 'sibling':
//         return gender === 'M' ? `${person.name}'s brother` : `${person.name}'s sister`;
//       case 'child':
//         return `${person.name}'s child`;
//       default:
//         return 'New relative';
//     }
//   };

//   const handleSubmit = () => {
//     // Create the base person object
//     const newPerson = {
//       name: `${relativeName} ${surname}`.trim(),
//       gender,
//       birth: { date: birthDate },
//       isLiving,
//       parentIds: {
//         father: fatherId || null,
//         mother: motherId || null
//       }
//     };

//     if (type === 'parents') {
//       // Create other parent details
//       const otherParent = {
//         name: otherParentName,
//         gender: otherParentGender,
//         birth: { date: otherParentBirthDate },
//         isLiving: true
//       };
//       onSave(type, newPerson, otherParent);
//     } else if (type === 'partner') {
//       if (selectedPartnerType === 'existing') {
//         onSave(type, { existingPartnerId: partnerId });
//       } else {
//         onSave(type, newPerson);
//       }
//     } else if (type === 'child') {
//       onSave(type, { ...newPerson, parentIds: { father: fatherId, mother: motherId } });
//     } else {
//       onSave(type, newPerson);
//     }
//   };

//   return (
//     <div className="space-y-4">
//       <h4 className="font-medium text-sm">Adding: {getRelativeLabel()}</h4>

//       {type === 'partner' && (
//         <div className="mb-4">
//           <label className="block text-sm text-gray-700 mb-1">Partner Type:</label>
//           <select
//             value={selectedPartnerType}
//             onChange={(e) => setSelectedPartnerType(e.target.value)}
//             className="w-full px-3 py-2 border border-gray-300 rounded-md"
//           >
//             <option value="new">Add new partner</option>
//             <option value="existing">Select existing person</option>
//           </select>
//         </div>
//       )}

//       {(selectedPartnerType === 'existing' && type === 'partner') ? (
//         <div>
//           <label className="block text-sm text-gray-700 mb-1">Select Existing Partner:</label>
//           <select
//             value={partnerId}
//             onChange={(e) => setPartnerId(e.target.value)}
//             className="w-full px-3 py-2 border border-gray-300 rounded-md"
//           >
//             <option value="">Select a person</option>
//             {Object.values(individuals)
//               .filter(ind => ind.id !== person.id)
//               .map(ind => (
//                 <option key={ind.id} value={ind.id}>{ind.name}</option>
//               ))
//             }
//           </select>
//         </div>
//       ) : (
//         <>
//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Given names:</label>
//             <input
//               type="text"
//               value={relativeName}
//               onChange={(e) => setRelativeName(e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             />
//           </div>

//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Surname:</label>
//             <input
//               type="text"
//               value={surname}
//               onChange={(e) => setSurname(e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             />
//           </div>

//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Gender:</label>
//             <div className="flex gap-4">
//               <label className="flex items-center">
//                 <input
//                   type="radio"
//                   checked={gender === 'F'}
//                   onChange={() => setGender('F')}
//                   className="mr-2"
//                 />
//                 Female
//               </label>
//               <label className="flex items-center">
//                 <input
//                   type="radio"
//                   checked={gender === 'M'}
//                   onChange={() => setGender('M')}
//                   className="mr-2"
//                 />
//                 Male
//               </label>
//             </div>
//           </div>

//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Birth date:</label>
//             <input
//               type="text"
//               value={birthDate}
//               onChange={(e) => setBirthDate(e.target.value)}
//               placeholder="e.g., 1 JAN 1990"
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             />
//           </div>
//         </>
//       )}

//       {type === 'child' && (
//         <>
//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Father:</label>
//             <select
//               value={fatherId}
//               onChange={(e) => setFatherId(e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             >
//               <option value="">Select father (optional)</option>
//               {Object.values(individuals)
//                 .filter(ind => ind.gender === 'M')
//                 .map(ind => (
//                   <option key={ind.id} value={ind.id}>{ind.name}</option>
//                 ))
//               }
//             </select>
//           </div>
//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Mother:</label>
//             <select
//               value={motherId}
//               onChange={(e) => setMotherId(e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             >
//               <option value="">Select mother (optional)</option>
//               {Object.values(individuals)
//                 .filter(ind => ind.gender === 'F')
//                 .map(ind => (
//                   <option key={ind.id} value={ind.id}>{ind.name}</option>
//                 ))
//               }
//             </select>
//           </div>
//         </>
//       )}

//       {type === 'parents' && (
//         <div className="mt-4 border-t pt-4">
//           <h4 className="font-medium text-sm mb-2">Other Parent Details:</h4>
//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Name:</label>
//             <input
//               type="text"
//               value={otherParentName}
//               onChange={(e) => setOtherParentName(e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             />
//           </div>
//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Gender:</label>
//             <div className="flex gap-4">
//               <label className="flex items-center">
//                 <input
//                   type="radio"
//                   checked={otherParentGender === 'F'}
//                   onChange={() => setOtherParentGender('F')}
//                   className="mr-2"
//                 />
//                 Female
//               </label>
//               <label className="flex items-center">
//                 <input
//                   type="radio"
//                   checked={otherParentGender === 'M'}
//                   onChange={() => setOtherParentGender('M')}
//                   className="mr-2"
//                 />
//                 Male
//               </label>
//             </div>
//           </div>
//           <div>
//             <label className="block text-sm text-gray-700 mb-1">Birth date:</label>
//             <input
//               type="text"
//               value={otherParentBirthDate}
//               onChange={(e) => setOtherParentBirthDate(e.target.value)}
//               placeholder="e.g., 1 JAN 1990"
//               className="w-full px-3 py-2 border border-gray-300 rounded-md"
//             />
//           </div>
//         </div>
//       )}

//       <div className="flex gap-2 mt-6">
//         <button
//           onClick={handleSubmit}
//           className="flex-1 px-4 py-2 text-sm text-white bg-blue-600 rounded-md hover:bg-blue-700"
//         >
//           OK
//         </button>
//         <button
//           onClick={onCancel}
//           className="flex-1 px-4 py-2 text-sm text-gray-700 bg-gray-100 rounded-md hover:bg-gray-200"
//         >
//           Cancel
//         </button>
//       </div>
//     </div>
//   );
// };

// return (
//   <div className="fixed right-4 top-4 w-80 bg-white p-4 rounded-lg shadow-xl border border-gray-200 z-50">
//   <div className="flex justify-between items-center mb-4">
//   <h3 className="text-lg font-semibold text-gray-900">Person Details</h3>
//   <button 
//     onClick={onClose}
//     className="text-gray-400 hover:text-gray-600 focus:outline-none"
//   >
//     ×
//   </button>
// </div>
// <button 
//   onClick={() => {
//     if (window.confirm('Are you sure you want to delete this person?')) {
//       const updatedIndividuals = {...individuals};
//       delete updatedIndividuals[person.id];
      
//       const updatedFamilies = {...families};
//       Object.entries(updatedFamilies).forEach(([id, family]) => {
//         if (family.husband === person.id || family.wife === person.id) {
//           delete updatedFamilies[id];
//         }
//         if (family.children.includes(person.id)) {
//           family.children = family.children.filter(childId => childId !== person.id);
//         }
//       });
      
//       onSave({
//         __updates: {
//           individuals: updatedIndividuals,
//           families: updatedFamilies,
//           gedcom: generateUpdatedGEDCOM(updatedIndividuals, updatedFamilies)
//         }
//       });
//       onClose();
//     }
//   }}
//   className="w-full px-4 py-2 mb-4 text-sm text-white bg-red-600 rounded-md hover:bg-red-700"
// >
//   Delete Person
// </button>
//     {showAddRelative ? (
//   <AddRelativeForm
//     type={addingRelativeType}
//     person={person}
//     onSave={handleSaveNewRelative}
//     onCancel={() => {
//       setShowAddRelative(false);
//       setAddingRelativeType(null);
//     }}
//     individuals={individuals}  // Add this
//     families={families}      // Add this
//   />
// ) : isEditing ? (
//         <div className="space-y-4">
//           <div>
//             <label className="block text-sm font-medium text-gray-700 mb-1">Name:</label>
//             <input
//               type="text"
//               value={editedPerson.name || ''}
//               onChange={(e) => handleChange('name', e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
//             />
//           </div>
//           <div>
//             <label className="block text-sm font-medium text-gray-700 mb-1">Gender:</label>
//             <select
//               value={editedPerson.gender || 'U'}
//               onChange={(e) => handleChange('gender', e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
//             >
//               <option value="M">Male</option>
//               <option value="F">Female</option>
//               <option value="U">Unknown</option>
//             </select>
//           </div>
//           <div>
//             <label className="block text-sm font-medium text-gray-700 mb-1">Birth Date:</label>
//             <input
//               type="text"
//               value={editedPerson.birth?.date || ''}
//               onChange={(e) => handleChange('birth', e.target.value)}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
//               placeholder="e.g., 1 JAN 1990"
//             />
//           </div>
          
//           <div className="flex gap-2 mt-4">
//             <button 
//               onClick={handleSave}
//               className="flex-1 px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
//             >
//               Save
//             </button>
//             <button 
//               onClick={() => {
//                 setIsEditing(false);
//                 setEditedPerson(person);
//               }}
//               className="flex-1 px-4 py-2 text-sm font-medium text-white bg-gray-600 rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2"
//             >
//               Cancel
//             </button>
//           </div>
//         </div>
//       ) : (
//         <div className="space-y-3">
//           <p className="text-sm"><span className="font-medium">Name:</span> {editedPerson.name || 'Unknown'}</p>
//           <p className="text-sm"><span className="font-medium">Gender:</span> {editedPerson.gender === 'M' ? 'Male' : editedPerson.gender === 'F' ? 'Female' : 'Unknown'}</p>
//           <p className="text-sm"><span className="font-medium">Birth Date:</span> {editedPerson.birth?.date || 'Unknown'}</p>

//           <div className="mt-6 pt-4 border-t border-gray-200">
//             <h4 className="font-medium text-sm mb-2">Find Relationship</h4>
//             <select 
//               value={selectedRelativePerson || ''}
//               onChange={(e) => {
//                 const selectedId = e.target.value;
//                 setSelectedRelativePerson(selectedId);
//                 findRelationship(selectedId);
//               }}
//               className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 mb-2"
//             >
//               <option value="">Select a Person</option>
//               {Object.values(individuals)
//                 .filter(ind => ind.id !== person.id)
//                 .map(ind => (
//                   <option key={ind.id} value={ind.id}>
//                     {ind.name}
//                   </option>
//                 ))
//               }
//             </select>
            
//             {relationship && (
//               <div className="bg-gray-50 p-3 rounded-md">
//                 <p className="text-sm">
//                   Relationship: <span className="font-medium">{relationship}</span>
//                 </p>
//               </div>
//             )}
//           </div>

//           <button 
//             onClick={() => setIsEditing(true)}
//             className="w-full px-4 py-2 mt-4 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
//           >
//             Edit
//           </button>
//           <AddRelativeButtons
//           person={person}
//           onAddRelative={handleAddRelative}
//         />
//       </div>
//     )}
//   </div>
// );
// };

// const FamilyTree = () => {
//   const [data, setData] = useState(null);
//   const [selectedPerson, setSelectedPerson] = useState(null);
//   const [showDetails, setShowDetails] = useState(false);
//   const [error, setError] = useState(null);
//   const [parsedData, setParsedData] = useState(null);
//   const [gedcomText, setGedcomText] = useState('');
//   const svgRef = useRef();
//   const [zoomLevel, setZoomLevel] = useState(1);
//   const [contextMenuPosition, setContextMenuPosition] = useState({ x: 0, y: 0 });
//   const [showContextMenu, setShowContextMenu] = useState(false);

//   const handleFileUpload = (event) => {
//     const file = event.target.files[0];
//     setError(null);
//     setData(null);
//     setSelectedPerson(null);
//     setShowDetails(false);
//     if (file) {
//       const reader = new FileReader();
//       reader.onload = (e) => {
//         try {
//           const gedcomData = parseGEDCOM(e.target.result);
//           setParsedData(gedcomData);
//           setGedcomText(e.target.result);
//         } catch (err) {
//           setError('Error parsing GEDCOM file. Please check the file format.');
//           console.error('Parsing error:', err);
//         }
//       };
//       reader.onerror = () => {
//         setError('Error reading file. Please try again.');
//       };
//       reader.readAsText(file);
//     }
//   };
  
//   const handleTextInput = (event) => {
//     const text = event.target.value;
//     setGedcomText(text);
//     try {
//       const gedcomData = parseGEDCOM(text);
//       setParsedData(gedcomData);
//       setError(null);
//     } catch (err) {
//       setError('Error parsing GEDCOM text. Please check the format.');
//       console.error('Parsing error:', err);
//     }
//   };

//   const handleGenerateTree = () => {
//     if (!parsedData) {
//       setError('Please provide GEDCOM data first.');
//       return;
//     }
  
//     const { individuals, families } = parsedData;
//     if (!individuals || !families || Object.keys(families).length === 0) {
//       setError('No valid family data found.');
//       return;
//     }
  
//     setError(null);
//     const rootFamily = Object.values(families)[0];
//     setData({ individuals, families, rootFamily });
//   };
  
//   const handleNodeClick = (person) => {
//     setSelectedPerson(person);
//     setShowDetails(true);
//   };

//   const handleContextMenu = (e, person) => {
//     e.preventDefault();
//     const contextMenu = document.getElementById('contextMenu');
//     if (contextMenu) {
//       contextMenu.style.display = 'block';
//       contextMenu.style.left = `${e.pageX}px`;
//       contextMenu.style.top = `${e.pageY}px`;
//       setSelectedPerson(person);
//     }
//   };
  
//   const handleDetailsSave = (updatedPerson) => {
//     if (!data) return;
  
//     let newData;
    
//     if (updatedPerson.__updates) {
//       // Handle complete data update (for new relatives)
//       newData = {
//         ...data,
//         individuals: updatedPerson.__updates.individuals,
//         families: updatedPerson.__updates.families
//       };
//       setGedcomText(updatedPerson.__updates.gedcom);
//     } else {
//       // Handle single person update
//       const updatedIndividuals = {
//         ...data.individuals,
//         [updatedPerson.id]: updatedPerson
//       };
      
//       newData = {
//         ...data,
//         individuals: updatedIndividuals
//       };
      
//       const updatedGedcom = generateUpdatedGEDCOM(updatedIndividuals, data.families);
//       setGedcomText(updatedGedcom);
//     }
  
//     setData(newData);
//     setSelectedPerson(updatedPerson);
//   };

//   const handleDownloadGedcom = () => {
//     const blob = new Blob([gedcomText], { type: 'text/plain' });
//     const url = URL.createObjectURL(blob);
//     const a = document.createElement('a');
//     a.href = url;
//     a.download = 'updated_family_tree.ged';
//     document.body.appendChild(a);
//     a.click();
//     document.body.removeChild(a);
//     URL.revokeObjectURL(url);
//   };
//   useEffect(() => {
//     if (!data || !svgRef.current) return;
  
//     const width = 1000;
//     const height = 600;
//     const nodeWidth = 100;
//     const nodeHeight = 35;
//     const spouseGap = 20;
//     const levelGap = 80;
    
//     // Clear previous SVG content
//     d3.select(svgRef.current).selectAll("*").remove();
  
//     const svg = d3.select(svgRef.current)
//       .attr('width', width)
//       .attr('height', height)
//       .append('g')
//       .attr('transform', `translate(${width / 2},50)`);
  
//     // Modified tree layout to ensure proper centering
//     const treeLayout = d3.tree()
//     .nodeSize([nodeWidth * 2.5, nodeHeight * 4])
//     .separation((a, b) => {
//       // Adjust separation based on whether nodes share the same parent
//       if (a.parent === b.parent) {
//         // If either node is an only child, reduce separation to center it
//         if (a.parent && a.parent.children.length === 1) {
//           return 0.8;  // Reduced separation for single children
//         }
//         return 1.2;    // Normal sibling separation
//       }
//       return 1.8;      // Separation between different parent nodes
//     });

//     const centerSingleChildren = (node) => {
//       if (node.children) {
//         node.children.forEach(centerSingleChildren);
        
//         // If there's only one child, adjust its position
//         if (node.children.length === 1 && node.data.spouse) {
//           const child = node.children[0];
//           // Center the child between the parents
//           child.x = node.x + (nodeWidth + spouseGap) / 2;
//         }
//       }
//       return node;
//     };
  
//     // Modified hierarchy creation to handle centering
//     const createHierarchy = (familyId, processedNodes = new Set()) => {
//       const family = data.families[familyId];
//       if (!family) return null;
  
//       const rootNode = {
//         id: familyId,
//         children: [],
//         family: family,
//         centerOffset: 0 // Add center offset tracking
//       };
  
//       if (family.husband && family.wife) {
//         rootNode.primary = data.individuals[family.husband];
//         rootNode.spouse = data.individuals[family.wife];
//         rootNode.centerOffset = (nodeWidth + spouseGap) / 2; // Center between spouses
//       }
  
//       if (family.children) {
//         const childrenNodes = [];
//         family.children.forEach(childId => {
//           if (processedNodes.has(childId)) return;
//           processedNodes.add(childId);
  
//           const person = data.individuals[childId];
//           const childFamilies = Object.values(data.families)
//             .filter(f => f.husband === childId || f.wife === childId);
  
//           if (childFamilies.length > 0) {
//             childFamilies.forEach(childFamily => {
//               const childNode = {
//                 id: childId,
//                 familyId: childFamily.id,
//                 primary: person,
//                 spouse: childFamily.husband === childId 
//                   ? data.individuals[childFamily.wife]
//                   : data.individuals[childFamily.husband],
//                 children: [],
//                 centerOffset: (nodeWidth + spouseGap) / 2
//               };
  
//               if (childFamily.children) {
//                 childFamily.children.forEach(grandChildId => {
//                   const grandChild = data.individuals[grandChildId];
//                   childNode.children.push({
//                     id: grandChildId,
//                     individual: grandChild,
//                     centerOffset: nodeWidth / 2
//                   });
//                 });
//               }
//               childrenNodes.push(childNode);
//             });
//           } else {
//             childrenNodes.push({
//               id: childId,
//               individual: person,
//               centerOffset: nodeWidth / 2
//             });
//           }
//         });
//         rootNode.children = childrenNodes;
//       }
  
//       return rootNode;
//     };
  
//     const hierarchy = d3.hierarchy(createHierarchy(data.rootFamily.id));
//     const treeData = treeLayout(hierarchy);
//     centerSingleChildren(treeData);

  
//     // Modified line drawing logic
//      const drawConnectingLines = () => {
//     const drawLine = (x1, y1, x2, y2, isSpouseLine = false) => {
//       svg.append('line')
//         .attr('x1', x1)
//         .attr('y1', y1)
//         .attr('x2', x2)
//         .attr('y2', y2)
//         .attr('stroke', '#666')
//         .attr('stroke-width', isSpouseLine ? 3 : 1.5);
//     };

//     treeData.descendants().forEach(d => {
//       // Draw spouse connections
//       if (d.data.primary && d.data.spouse) {
//         const spouseLineY = d.y + nodeHeight/2;
//         const startX = d.x + nodeWidth;
//         const endX = d.x + nodeWidth + spouseGap;
//         drawLine(startX, spouseLineY, endX, spouseLineY, true);
//       }

//       // Draw parent-child connections
//       if (d.children && d.children.length > 0) {
//         const parentCenterX = d.data.spouse ? 
//           d.x + nodeWidth + spouseGap/2 : // Center between spouses
//           d.x + nodeWidth/2;              // Center of single parent
//         const startY = d.y + nodeHeight;
//         const midY = startY + (d.children[0].y - startY)/2;

//         // Draw vertical line from parent center
//         drawLine(parentCenterX, startY, parentCenterX, midY);

//         if (d.children.length === 1) {
//           // For single child, draw straight vertical line
//           const childX = d.children[0].x + nodeWidth/2;
//           drawLine(parentCenterX, midY, childX, d.children[0].y);
//         } else {
//           // For multiple children, draw connecting lines
//           const leftX = d.children[0].x + nodeWidth/2;
//           const rightX = d.children[d.children.length-1].x + nodeWidth/2;
//           drawLine(leftX, midY, rightX, midY);

//           d.children.forEach(child => {
//             const childX = child.x + nodeWidth/2;
//             drawLine(childX, midY, childX, child.y);
//           });
//         }
//       }
//     });
//   };  
//     // Helper function to draw lines
//     const drawLine = (x1, y1, x2, y2, isSpouseLine = false) => {
//       svg.append('line')
//         .attr('x1', x1)
//         .attr('y1', y1)
//         .attr('x2', x2)
//         .attr('y2', y2)
//         .attr('stroke', '#666')
//         .attr('stroke-width', isSpouseLine ? 3 : 1.5);
//     };
  
//     // Draw lines first
//     drawConnectingLines();
  
//     // Create and draw nodes
//     const nodes = svg.selectAll('g.node')
//       .data(treeData.descendants())
//       .enter()
//       .append('g')
//       .attr('class', 'node')
//       .attr('transform', d => `translate(${d.x},${d.y})`);
  
//     nodes.each(function(d) {
//       const node = d3.select(this);
      
//       if (d.data.primary) {
//         drawPerson(node, d.data.primary, 0, 0);
//         if (d.data.spouse) {
//           drawPerson(node, d.data.spouse, nodeWidth + spouseGap, 0);
//         }
//       } else if (d.data.individual) {
//         drawPerson(node, d.data.individual, 0, 0);
//       }
//     });
  
//     function drawPerson(container, person, x, y) {
//       const group = container.append('g')
//         .attr('transform', `translate(${x},${y})`)
//         .style('cursor', 'pointer')
//         .on('click', () => handleNodeClick(person))
//         .on('contextmenu', (e) => handleContextMenu(e, person));
    
//       // Add the existing rectangle and text elements
//       group.append('rect')
//         .attr('fill', person.gender === 'M' ? '#b8daff' : '#ffd6e5')
//         .attr('stroke', person.gender === 'M' ? '#84b9ff' : '#ffadd2')
//         .attr('stroke-width', 2)
//         .attr('width', nodeWidth)
//         .attr('height', nodeHeight)
//         .attr('rx', 5)
//         .attr('ry', 5);
    
//       group.append('text')
//         .attr('x', nodeWidth/2)
//         .attr('y', nodeHeight/2)
//         .attr('text-anchor', 'middle')
//         .attr('dominant-baseline', 'middle')
//         .attr('font-family', 'Arial')
//         .attr('font-size', '11px')
//         .text(person.name);
    
//       // Add delete icon
//       group.append('text')
//         .attr('x', nodeWidth - 15)
//         .attr('y', 15)
//         .attr('text-anchor', 'middle')
//         .attr('dominant-baseline', 'middle')
//         .attr('font-family', 'Arial')
//         .attr('font-size', '12px')
//         .attr('cursor', 'pointer')
//         .text('×')
//         .on('click', (e) => {
//           e.stopPropagation();
//           if (window.confirm('Are you sure you want to delete this person?')) {
//             const updatedIndividuals = {...data.individuals};
//             delete updatedIndividuals[person.id];
            
//             const updatedFamilies = {...data.families};
//             Object.entries(updatedFamilies).forEach(([id, family]) => {
//               if (family.husband === person.id || family.wife === person.id) {
//                 delete updatedFamilies[id];
//               }
//               if (family.children.includes(person.id)) {
//                 family.children = family.children.filter(childId => childId !== person.id);
//               }
//             });
            
//             setData({
//               ...data,
//               individuals: updatedIndividuals,
//               families: updatedFamilies
//             });
//           }
//         });
//     }
    
  
//     // Add zoom behavior
//     const zoom = d3.zoom()
//       .scaleExtent([0.3, 2])
//       .on('zoom', (event) => {
//         svg.attr('transform', event.transform);
//         setZoomLevel(event.transform.k);
//       });
  
//     d3.select(svgRef.current).call(zoom);
  
//     // Initial zoom to fit content
//     const svgElement = svgRef.current;
//     const bbox = svgElement.getBBox();
//     const scale = Math.min(
//       width / bbox.width,
//       height / bbox.height
//     ) * 0.9;
    
//     const transform = d3.zoomIdentity
//       .translate(
//         width/2 - bbox.x*scale - bbox.width*scale/2,
//         height/2 - bbox.y*scale - bbox.height*scale/2
//       )
//       .scale(scale);
    
//     d3.select(svgRef.current)
//       .transition()
//       .duration(750)
//       .call(zoom.transform, transform);
  
//   }, [data]);

//   useEffect(() => {
//     const handleClick = (e) => {
//       const contextMenu = document.getElementById('contextMenu');
//       if (contextMenu && !contextMenu.contains(e.target)) {
//         contextMenu.style.display = 'none';
//       }
//     };
  
//     document.addEventListener('click', handleClick);
//     return () => document.removeEventListener('click', handleClick);
//   }, []);

//   // Replace the return statement in your FamilyTree component with this:
//   return (
//     <div className="flex flex-col min-h-screen bg-slate-50 p-4">
//       {/* Upload Section */}
//       <div className="mb-4 space-y-4">
//         <div className="flex flex-wrap gap-4 items-start">
//           <div className="flex-1 space-y-2">
//             <input
//               type="file"
//               accept=".ged"
//               onChange={handleFileUpload}
//               className="block w-full px-3 py-2 text-sm text-gray-700 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
//             />
//             <textarea
//               value={gedcomText}
//               onChange={handleTextInput}
//               placeholder="Or paste your GEDCOM data here..."
//               className="w-full h-32 px-3 py-2 text-sm border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
//             />
//           </div>
//           <button 
//             onClick={handleGenerateTree}
//             disabled={!parsedData}
//             className="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
//           >
//             Generate Family Tree
//           </button>
//         </div>
  
//         {parsedData && (
//           <div className="flex items-center gap-2 text-green-600">
//             <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
//               <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
//             </svg>
//             <span>Data loaded successfully</span>
//           </div>
//         )}
  
//         {error && (
//           <div className="p-3 text-red-700 bg-red-50 rounded-md">
//             {error}
//           </div>
//         )}
//       </div>
  
//       {/* Tree Visualization */}
//       <div className="flex-1 bg-white rounded-lg shadow-lg overflow-hidden">
//         <div className="relative w-full h-[calc(100vh-16rem)] overflow-auto">
//           <svg 
//             ref={svgRef}
//             className="min-w-full min-h-full"
//           />
          
//           {showDetails && selectedPerson && data?.individuals?.[selectedPerson.id] && (
//             <PersonDetailsPanel
//               person={data.individuals[selectedPerson.id]}
//               onClose={() => setShowDetails(false)}
//               onSave={handleDetailsSave}
//               individuals={data.individuals}
//               families={data.families}
//             />
//           )}
//         </div>
//       </div>
  
//       {/* Legend and Controls */}
//       {data && (
//         <div className="mt-4 flex justify-between items-center">
//           <div className="flex items-center gap-4">
//             <div className="flex items-center gap-2">
//               <div className="w-4 h-4 rounded border border-blue-300 bg-blue-100"></div>
//               <span className="text-sm text-gray-600">Male</span>
//             </div>
//             <div className="flex items-center gap-2">
//               <div className="w-4 h-4 rounded border border-pink-300 bg-pink-100"></div>
//               <span className="text-sm text-gray-600">Female</span>
//             </div>
//           </div>
//           <button 
//             onClick={handleDownloadGedcom}
//             className="px-4 py-2 text-sm font-medium text-white bg-green-600 rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2"
//           >
//             Download Updated GEDCOM
//           </button>
//         </div>
//       )}
//       <div 
//   id="contextMenu" 
//   className="fixed hidden bg-white shadow-lg rounded-md py-2 border border-gray-200 z-50"
//   style={{ minWidth: '200px' }}
// >
//   <button 
//     onClick={() => {
//       if (selectedPerson && window.confirm('Are you sure you want to delete this person?')) {
//         const updatedIndividuals = {...data.individuals};
//         delete updatedIndividuals[selectedPerson.id];
        
//         const updatedFamilies = {...data.families};
//         Object.entries(updatedFamilies).forEach(([id, family]) => {
//           if (family.husband === selectedPerson.id || family.wife === selectedPerson.id) {
//             delete updatedFamilies[id];
//           }
//           if (family.children.includes(selectedPerson.id)) {
//             family.children = family.children.filter(childId => childId !== selectedPerson.id);
//           }
//         });
        
//         setData({
//           ...data,
//           individuals: updatedIndividuals,
//           families: updatedFamilies
//         });
//         document.getElementById('contextMenu').style.display = 'none';
//       }
//     }}
//     className="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-gray-100"
//   >
//     Delete Person
//   </button>
// </div>
//     </div>
//   );
// };

// const generateUpdatedGEDCOM = (individuals, families) => {
//   let gedcom = '0 HEAD\n1 CHAR UTF-8\n';

//   // Add individuals
//   Object.values(individuals).forEach(individual => {
//     gedcom += `0 @${individual.id}@ INDI\n`;
//     gedcom += `1 NAME ${individual.name}\n`;
//     gedcom += `1 SEX ${individual.gender}\n`;
//     if (individual.birth?.date) {
//       gedcom += '1 BIRT\n';
//       gedcom += `2 DATE ${individual.birth.date}\n`;
//     }
//     // Add living status if available
//     if (individual.isLiving !== undefined) {
//       gedcom += `1 DEAT\n`;
//       gedcom += `2 TYPE ${individual.isLiving ? 'N' : 'Y'}\n`;
//     }
//   });

//   // Add families
//   Object.values(families).forEach(family => {
//     gedcom += `0 @${family.id}@ FAM\n`;
//     if (family.husband) gedcom += `1 HUSB @${family.husband}@\n`;
//     if (family.wife) gedcom += `1 WIFE @${family.wife}@\n`;
//     family.children.forEach(childId => {
//       gedcom += `1 CHIL @${childId}@\n`;
//     });
//   });

//   gedcom += '0 TRLR\n';
//   return gedcom;
// };
// export default FamilyTree;